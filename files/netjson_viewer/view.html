<!doctype html>
<html>
<head>
  <title>Network | Basic usage</title>

  <!-- This file use the http://visjs.org API -->

  <script type="text/javascript" src="vis.js"></script>
  <link href="vis.css" rel="stylesheet" type="text/css" />

  <style type="text/css">
    #mynetwork {
      width: 1280px;
      height: 768px;
      border: 1px solid lightgray;
    }
  </style>
</head>
<body>

<p>
  Visualization of olsrd2 netjson graph
</p>

Auto Update: <input type="checkbox" id="autoupdate" onclick="checkbox_clicked();" checked="checked"/>

<div id="mynetwork"></div>

<script type="text/javascript">
var visNodes, visEdges, visData, visNetwork;
var firstLookup;
var autoupdate_timeout;
var common_edge_postfix = "bit/s";

// this URL should return the netjson graph output
var netjsonurl = "http://169.254.0.101/cgi/netjson.cgi";

function init_network() {
    var options = {
    };

    // create an array with nodes
    visNodes = new vis.DataSet([], options);

    // create an array with edges
    visEdges = new vis.DataSet([], options);

    // create a network
    var container = document.getElementById('mynetwork');
    var visData = {
        nodes: visNodes,
        edges: visEdges
    };

    options = {
        edges: {
            smooth: {
                type: 'continuous'
            }
        },
    };
    visNetwork = new vis.Network(container, visData, options);
  
    firstLookup = true;
}

function layout_nodes(element) {
    var jsonNodes = element.nodes;
    var newIds = []
    var oldIds = []
    
    /* add new nodes */
    newIds = []
    oldIds = visNodes.getIds()
    for (ni = 0; ni < jsonNodes.length; ni++) {
        var nId = jsonNodes[ni].id;
        var nBorder = 1;

        var idx = nId.lastIndexOf('.');
        var nLabel = nId.substring(idx+1, nId.length);
                
        newIds.push(nId);
        if (jsonNodes[ni].id == element.router_id) {
            nBorder = 5;
        }

        if (!visNodes.get(nId)) {    
            visNodes.add(
                {
                    id:          nId,
                    label:       nLabel,
                    borderWidth: nBorder,
                    mass:        4,
                }
            );
        }
    }
    
    /* remove old nodes */
    for (ni = 0; ni < oldIds.length; ni++) {
        if (newIds.indexOf(oldIds[ni]) == -1) {
            visNodes.remove(oldIds[ni]);
        }
    }
}

function layout_edges(element) {
    var jsonEdges = element.links;
    var newIds = []
    var oldIds = []
    var undirectedEdges = {}
    
    /* calculate unidirectional edges */
    newIds = []
    oldIds = visEdges.getIds()
    for (ei = 0; ei < jsonEdges.length; ei++) {
        var eFrom = jsonEdges[ei].source;
        var eTo = jsonEdges[ei].target;
        
        if (eFrom > eTo) {
            var tmp = eTo;
            eTo = eFrom;
            eFrom = tmp;
        }

        var uuid = eFrom + "-" + eTo;
        
        var edge = undirectedEdges[uuid];
        if (edge == null) {
            edge = {
                uuid:      eFrom + "-" + eTo,
                from:      eFrom,
                to:        eTo,
                width:     1,
                arrows:    "",
                fromLabel: "-",
                toLabel:   "-"
            };
            undirectedEdges[uuid] = edge;
        };
                
        newIds.push(edge.uuid);
        
        var eLabel =  jsonEdges[ei].weight.toString();
        if (jsonEdges[ei].properties) {
            if (jsonEdges[ei].properties["weight_txt"]) {
                eLabel = jsonEdges[ei].properties["weight_txt"];
            }
            if (jsonEdges[ei].properties["outgoing_tree"] == "true") {
                edge.width=3;
                if (jsonEdges[ei].source == eFrom) {
                    edge.arrows = "to";
                }
                else {
                    edge.arrows = "from";
                }
            }
        }
        
        if (jsonEdges[ei].source == eFrom) {
            edge.fromLabel = eLabel;
        }
        else {
            edge.toLabel = eLabel;
        }
    }
    
    /* add new edges */
    for (ei = 0; ei < newIds.length; ei++) {
        var edge = undirectedEdges[newIds[ei]];
        var label = "";
        
        var flen = edge.fromLabel.length - common_edge_postfix.length;
        var tlen = edge.toLabel.length - common_edge_postfix.length;
        
        if (edge.fromLabel == edge.toLabel) {
            label = edge.fromLabel;
        }
        else if (edge.fromLabel.substring(flen) == common_edge_postfix
                && edge.fromLabel.substring(flen) == common_edge_postfix) {
            label = edge.fromLabel.substring(0, flen).trim() + "/"
                + edge.toLabel.substring(0, tlen).trim()
                + " " + common_edge_postfix;             
        }
        else {
            label = edge.fromLabel + "/" + edge.toLabel;
        }
        
        if (visEdges.get(edge.uuid)) {
            visEdges.update(
                {
                    id:          edge.uuid,
                    label:       label,
                    width:       edge.width,
                    arrows:      edge.arrows,
                }
            );
        }
        else {
            visEdges.add(
                {
                    id:          edge.uuid,
                    from:        edge.from,
                    to:          edge.to,
                    label:       label,
                    length:      200,
                    width:       edge.width,
                    arrows:      edge.arrows,
                    font: {
                        align:       "top",
                    }
                }
            );
        }
    }

    /* remove old edges */
    for (ei = 0; ei < oldIds.length; ei++) {
        if (newIds.indexOf(oldIds[ei]) == -1) {
            visEdges.remove(oldIds[ei]);
        }
    }
}

function xmlhttp_changed()
{
    if (xmlhttp.readyState==XMLHttpRequest.DONE && xmlhttp.status==200) {
        console.log("Got update");
        
        obj = JSON.parse(xmlhttp.responseText);

        if (obj.type != "NetworkCollection") {
            return;
        }

        for (index = 0; index < obj.collection.length; index++) {
            element = obj.collection[index];

            if (element.router_id.indexOf(':') != -1) {
                continue;
            }

            if (element.type == "NetworkGraph") {
                layout_graph(element);
            }
        }
        
        var checkbox = document.getElementById("autoupdate");
        if (checkbox.checked) {
            autoupdate_timeout = window.setTimeout(send_request, 5000);
        }
    }
}

function checkbox_clicked() {
    var checkbox = document.getElementById("autoupdate");
    if (checkbox.checked === false) {
        window.clearTimeout(autoupdate_timeout);
    }
    else {
        send_request();
    }    
}

function send_request() {
    xmlhttp.open("GET",netjsonurl,true);
    xmlhttp.send();
}

var xmlhttp = new XMLHttpRequest();
xmlhttp.onreadystatechange=xmlhttp_changed

init_network();
send_request();

</script>

</body>
</html>
